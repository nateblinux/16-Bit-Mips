// Behavioral implementation of MIPS Register File (modified to 16 bit reg width over 4 regs)
module reg_file (RR1,RR2,WR,WD,RegWrite,RD1,RD2,clock);

  input [1:0] RR1,RR2,WR;
  input [15:0] WD;
  input RegWrite,clock;
  output [15:0] RD1,RD2;

  reg [15:0] Regs[0:3];

  assign RD1 = Regs[RR1];
  assign RD2 = Regs[RR2];

  initial Regs[0] = 0;

  always @(negedge clock)
    if (RegWrite==1 & WR!=0) 
	Regs[WR] <= WD;

endmodule

// Gate level implementation of a half adder
module halfadder (S,C,x,y);
   input x,y;
   output S,C;
   
   xor (S,x,y);
   and (C,x,y);
endmodule

// Gate level implementation of a full adder
module fulladder (S,C,x,y,z);
   input x,y,z;
   output S,C;
   wire S1,D1,D2; 
    halfadder HA1 (S1,D1,x,y),
              HA2 (S,D2,S1,z);
    or g1(C,D2,D1);
endmodule

// Gate level 2x1 multiplexor
module two_bit_multiplex(x, y, z, O);
    input x, y, z;
    output O;
    not n1(z1, z);
    and a1(S1, x, y),
       a2(S2, y, z),
       a3(S3, x, z1);
    or(O, S1, S2, S3);
endmodule

// Gate level 4x1 multiplexor
module four_bit_multiplex(A, B, C, D, ctrl1, ctrl2, O);
    input A, B, C, D, ctrl1, ctrl2;
    output O;
    two_bit_multiplex m1(A, B, ctrl1, tmp),
                      m2(C, D, ctrl1, tmp1),
                      m3(tmp, tmp1, ctrl2, O);
endmodule

//16 bit wide 2 to 1 multiplexer
module two_to_one_sixteen_bit_mux(x, y, z, O);
    input [15:0] x, y;
    input z;
    output [15:0] O;
    two_bit_multiplex mux0 (x[0], y[0], z, O[0]),
                      mux1 (x[1], y[1], z, O[1]),
                      mux2 (x[2], y[2], z, O[2]),
                      mux3 (x[3], y[3], z, O[3]),
                      mux4 (x[4], y[4], z, O[4]),
                      mux5 (x[5], y[5], z, O[5]),
                      mux6 (x[6], y[6], z, O[6]),
                      mux7 (x[7], y[7], z, O[7]),
                      mux8 (x[8], y[8], z, O[8]),
                      mux9 (x[9], y[9], z, O[9]),
                      mux10 (x[10], y[10], z, O[10]),
                      mux11 (x[11], y[11], z, O[11]),
                      mux12 (x[12], y[12], z, O[12]),
                      mux13 (x[13], y[13], z, O[13]),
                      mux14 (x[14], y[14], z, O[14]),
                      mux15 (x[15], y[15], z, O[15]);
endmodule

//2 bit wide 2 to 1 multiplexer
module two_to_one_two_bit_mux(x, y, z, O);
    input [1:0] x, y;
    input z;
    output [1:0] O;
    two_bit_multiplex mux0 (x[0], y[0], z, O[0]),
                      mux1 (x[1], y[1], z, O[1]);
endmodule

// Gate level implementation of all except the most significant 1 bit ALU
module one_bit_ALU(A, B, bnot, anot, less, carryIn, ctrl2, ctrl1, out, Cout);
    input A, B, bnot, anot, less, carryIn, ctrl1, ctrl2;
    output out, Cout;
    
    not n1(nA, A),
        n2(nB, B);
        
    two_bit_multiplex mA(A, nA, anot, uA),
                      mB(B, nB, bnot, uB);
    
    and a1(BandA, uA, uB);
    or  o1(BorA, uA, uB);
    
    fulladder adder(S, Cout, uA, uB, carryIn);
    
    four_bit_multiplex m1(BandA, BorA, S, less, ctrl1, ctrl2, out);
endmodule

// Gate level implementation of most significant 1 bit ALU
module one_bit_ALU2(A, B, bnot, anot, set, carryIn, ctrl2, ctrl1, out, Cout);
    input A, B, bnot, anot, carryIn, ctrl1, ctrl2;
    output out, Cout, set;
    
    not n1(nA, A),
        n2(nB, B);
        
    two_bit_multiplex mA(A, nA, anot, uA),
                      mB(B, nB, bnot, uB);
    
    and a1(BandA, uA, uB);
    or  o1(BorA, uA, uB);
    
    fulladder adder(S, Cout, uA, uB, carryIn);
    and(set, S, 1);
    
    four_bit_multiplex m1(BandA, BorA, S, 1'b0, ctrl1, ctrl2, out);
endmodule

// Gate level implementation of a 16 bit alu, comprised of 15 one_bit_ALU's and 1 one_bit_ALU2 for the most significant bit.
module alu(op, a, b, result, zero);
    input[3:0] op;
    input [15:0] a, b;
    output[15:0] result;
    output zero;
    
   one_bit_ALU a1 (a[0], b[0], op[2], op[3], set, op[2], op[1], op[0], result[0], Carry1);
   one_bit_ALU a2 (a[1], b[1], op[2], op[3], 1'b0, Carry1, op[1], op[0], result[1], Carry2);
   one_bit_ALU a3 (a[2], b[2], op[2], op[3], 1'b0, Carry2, op[1], op[0], result[2], Carry3);
   one_bit_ALU a4 (a[3], b[3], op[2], op[3], 1'b0, Carry3, op[1], op[0], result[3], Carry4);
   one_bit_ALU a5 (a[4], b[4], op[2], op[3], 1'b0, Carry4, op[1], op[0], result[4], Carry5);
   one_bit_ALU a6 (a[5], b[5], op[2], op[3], 1'b0, Carry5, op[1], op[0], result[5], Carry6);
   one_bit_ALU a7 (a[6], b[6], op[2], op[3], 1'b0, Carry6, op[1], op[0], result[6], Carry7);
   one_bit_ALU a8 (a[7], b[7], op[2], op[3], 1'b0, Carry7, op[1], op[0], result[7], Carry8);
   one_bit_ALU a9 (a[8], b[8], op[2], op[3], 1'b0, Carry8, op[1], op[0], result[8], Carry9);
   one_bit_ALU a10 (a[9], b[9], op[2], op[3], 1'b0, Carry9, op[1], op[0], result[9], Carry10);
   one_bit_ALU a11 (a[10], b[10], op[2], op[3], 1'b0, Carry10, op[1], op[0], result[10], Carry11);
   one_bit_ALU a12 (a[11], b[11], op[2], op[3], 1'b0, Carry11, op[1], op[0], result[11], Carry12);
   one_bit_ALU a13 (a[12], b[12], op[2], op[3], 1'b0, Carry12, op[1], op[0], result[12], Carry13);
   one_bit_ALU a14 (a[13], b[13], op[2], op[3], 1'b0, Carry13, op[1], op[0], result[13], Carry14);
   one_bit_ALU a15 (a[14], b[14], op[2], op[3], 1'b0, Carry14, op[1], op[0], result[14], Carry15);
   one_bit_ALU2 a16 (a[15], b[15], op[2], op[3], set, Carry15, op[1], op[0], result[15], Cout);
   
   xor(o1, Carry3, Cout);
   nor(zero, result[0], result[1], result[2], result[3], result[4], result[5], result[6], result[7], result[8], result[9], result[10], result[11], result[12], result[13], result[14], result[15]);
    
endmodule


module MainControl (Op,Control); 
  input [3:0] Op;
  output reg [6:0] Control;
// Control bits: RegDst,ALUSrc,RegWrite,ALUOp
  always @(Op) case (Op)
    4'b0010: Control <= 7'b1010000; // AND
    4'b0111: Control <= 7'b0110010; // ADDI
    4'b0000: Control <= 7'b1010010; //ADD
    4'b0001: Control <= 7'b1010110; //SUB
    4'b0011: Control <= 7'b1010001; //OR
    4'b0100: Control <= 7'b1011100; //NOR
    4'b0101: Control <= 7'b1011101; //NAND
    4'b0110: Control <= 7'b1010111; //SLT
    
  endcase
endmodule

module CPU (clock,PC,IFID_IR,IDEX_IR,WD);
  input clock;
  output [15:0] PC,IFID_IR,IDEX_IR,WD;
  
  initial begin
  
// Program with nop's - no hazards
    IMemory[0] = 16'b0111_00_01_00001111;  // addi $t1, $0,  15   ($t1=15)
    IMemory[1] = 16'b0111_00_10_00000111;  // addi $t2, $0,  7    ($t2=7)
    IMemory[2]  = 16'h0000;  // nop
    IMemory[3] = 16'b0010_01_10_11_000000;  // and  $t3, $t1, $t2  ($t3=7)
    IMemory[4]  = 16'h0000;  // nop
    IMemory[5] = 16'b0001_01_11_10_000000;  // sub  $t2, $t1, $t3  ($t2=8)
    IMemory[6]  = 16'h0000;  // nop
    IMemory[7] = 16'b0011_10_11_10_000000;  // or   $t2, $t2, $t3  ($t2=15)
    IMemory[8]  = 16'h0000;  // nop
    IMemory[9] = 16'b0000_10_11_11_000000;  // add  $t3, $t2, $t3  ($t3=22)
    IMemory[10]  = 16'h0000;  // nop
    IMemory[11] = 16'b0100_10_11_01_000000;  // nor  $t1, $t2, $t3  ($t1=-32)
    IMemory[12] = 16'b0110_11_10_01_000000;  // slt  $t1, $t3, $t2  ($t1=0)
    IMemory[13] = 16'b0110_10_11_01_000000;  // slt  $t1, $t2, $t3  ($t1=1)
  end
  /*

  initial begin 
// Program without nop's - wrong results due to data hazards
    IMemory[0] = 16'b0111_00_01_00001111;  // addi $t1, $0,  15   ($t1=15)
    IMemory[1] = 16'b0111_00_10_00000111;  // addi $t2, $0,  7    ($t2=7)
    IMemory[2] = 16'b0010_01_10_11_000000;  // and  $t3, $t1, $t2  ($t3=7)
    IMemory[3] = 16'b0001_01_11_10_000000;  // sub  $t2, $t1, $t3  ($t2=8)
    IMemory[4] = 16'b0011_10_11_10_000000;  // or   $t2, $t2, $t3  ($t2=15)
    IMemory[5] = 16'b0000_10_11_11_000000;  // add  $t3, $t2, $t3  ($t3=22)
    IMemory[6] = 16'b0100_10_11_01_000000;  // nor  $t1, $t2, $t3  ($t1=-32)
    IMemory[7] = 16'b0110_11_10_01_000000;  // slt  $t1, $t3, $t2  ($t1=0)
    IMemory[8] = 16'b0110_10_11_01_000000;  // slt  $t1, $t2, $t3  ($t1=1)
  end

*/
// Pipeline stages
//=== IF STAGE ===
   wire [15:0] NextPC;
   reg[15:0] PC, IMemory[0:1023];
//--------------------------------
   reg[15:0] IFID_IR;
//--------------------------------
   alu fetch (4'b0010,PC,16'b0100,NextPC,Unused);

//=== ID STAGE ===
   wire [6:0] Control;
   wire [15:0] RD1,RD2,SignExtend,WD;
   wire [15:0] FWD_RD1,FWD_RD2; // Outputs of the forwarding muxes
   reg [15:0] IDEX_IR; // For monitoring the pipeline
   reg IDEX_RegWrite,IDEX_ALUSrc,IDEX_RegDst;
   reg [3:0]  IDEX_ALUOp;
   reg [15:0] IDEX_RD1,IDEX_RD2,IDEX_SignExt;
   reg [1:0]  IDEX_rt,IDEX_rd;
   wire [1:0] WR;
   reg_file rf (IFID_IR[11:10],IFID_IR[9:8],WR,WD,IDEX_RegWrite,RD1,RD2,clock);
   MainControl MainCtr (IFID_IR[15:12],Control); 
   assign SignExtend = {{8{IFID_IR[7]}},IFID_IR[7:0]}; 

//=== EXE STAGE ===
   wire [15:0] B,ALUOut;
   wire [3:0] ALUctl;
   assign ALUctl = IDEX_ALUOp;
   alu ex (ALUctl, IDEX_RD1, B, ALUOut, Zero);
   //assign B  = (IDEX_ALUSrc) ? IDEX_SignExt: IDEX_RD2;   // ALUSrc Mux 
   two_to_one_sixteen_bit_mux ALUSrcMux(IDEX_RD2, IDEX_SignExt, IDEX_ALUSrc, B);
   //assign WR = (IDEX_RegDst) ? IDEX_rd: IDEX_rt;         // RegDst Mux
   two_to_one_two_bit_mux RegDstMux(IDEX_rt, IDEX_rd, IDEX_RegDst, WR);
   assign WD = ALUOut;

// Forwarding multiplexers
   assign FWD_RD1 = (IDEX_RegWrite && WR==IFID_IR[11:10]) ? ALUOut: RD1;
   assign FWD_RD2 = (IDEX_RegWrite && WR==IFID_IR[9:8]) ? ALUOut: RD2;

   initial begin
    PC = 0;
    IFID_IR = 0; // clear pipeline register to avoid forwarding from empty pipeline
    IDEX_RegWrite = 0; 
   end

// Running the pipeline
   always @(negedge clock) begin

// Stage 1 - IF
    PC <= NextPC;
    IFID_IR <= IMemory[PC>>2];

// Stage 2 - ID
    IDEX_IR <= IFID_IR; // For monitoring the pipeline
    {IDEX_RegDst,IDEX_ALUSrc,IDEX_RegWrite,IDEX_ALUOp} <= Control;    

//  No Forwarding
    IDEX_RD1 <= RD1; 
    IDEX_RD2 <= RD2;

//  Forwarding
//  IDEX_RD1 <= FWD_RD1; 
//  IDEX_RD2 <= FWD_RD2;

    IDEX_SignExt <= SignExtend;
    IDEX_rt <= IFID_IR[9:8];
    IDEX_rd <= IFID_IR[7:6];

// Stage 3 - EX
// No transfers needed here - on negedge WD is written into register WR
  end
endmodule

// Test module
module test ();
  reg clock;
  wire signed [15:0] PC,IFID_IR,IDEX_IR,WD;
  CPU test_cpu(clock,PC,IFID_IR,IDEX_IR,WD);
  always #1 clock = ~clock;
  initial begin
    $display ("PC  IFID_IR   IDEX_IR   WD");
    $monitor ("%2d  %b  %b  %2d",PC,IFID_IR,IDEX_IR,WD);
    clock = 1;
    #29 $finish;
  end
endmodule


/* Output
Program with nop's
---------------------------
 PC  IFID_IR   IDEX_IR   WD
 0  00000000  xxxxxxxx   x
 4  2009000f  00000000   x
 8  200a0007  2009000f  15
12  00000000  200a0007   7
16  012a5824  00000000   0
20  00000000  012a5824   7
24  012b5022  00000000   0
28  00000000  012b5022   8
32  014b5025  00000000   0
36  00000000  014b5025  15
40  014b5820  00000000   0
44  00000000  014b5820  22
48  014b4827  00000000   0
52  016a482a  014b4827  -32
56  014b482a  016a482a   0
60  xxxxxxxx  014b482a   1

Program without nop's
--------------------------
PC  IFID_IR   IDEX_IR   WD
 0  00000000  xxxxxxxx   x
 4  2009000f  00000000   x
 8  200a0007  2009000f  15
12  012a5824  200a0007   7
16  012b5022  012a5824   X
20  014b5025  012b5022   x
24  014b5820  014b5025   X
28  014b4827  014b5820   x
32  016a482a  014b4827   X
36  014b482a  016a482a   X
40  xxxxxxxx  014b482a   X
44  xxxxxxxx  xxxxxxxx   X
48  xxxxxxxx  xxxxxxxx   X
52  xxxxxxxx  xxxxxxxx   X
56  xxxxxxxx  xxxxxxxx   X
60  xxxxxxxx  xxxxxxxx   X
*/